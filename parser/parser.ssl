%  PT Parser.ssl        Ver. 4.2
%
% Date:  30 Jun 1980
%        (Revised v4.2 - 18 Dec 2019)
%
% Author:  Alan Rosselet
%
% Abstract
%
%     This module parses the syntax token stream emitted by the scanner
%   and emits a postfix stream of tokens to the semantic analyzer
%   module.  The parser detects and repairs syntax errors so that the
%   token stream emitted to the semantic analyzer is syntactically
%   legal (except for the special case of declaration phase errors - see
%   comment in the Block routine below).

Input :
        % Keywords must be first both here and in stdIdentifiers,
        % and they must appear in the exact same order
        
        pMod		 'mod'  % mod keyword added
        firstKeywordToken = pMod % first keyword token updated to pMod
        pPub		 'pub'  % pub keyword added
        pMain        'main' % main keyword added
        pLet		 'let'  % let keyword added
        pMut		 'mut'  % mut keyword added
        pFn		     'fn'   % fn keyword added
	    pLoop		 'loop' % loop keyword added
	    pBreak		 'break' % break keyword added
	    pMatch		 'match' % match keyword added
        pElse        'else'
        pOf          'of'
        pFile        'file'
        pConst       'const'
        pType        'type'
        pIf          'if'
        pWhile       'while'
        lastKeywordToken = pWhile % last keyword token modifed to pWhile

        % Compound tokens - 
        %   These will be sent to the parser with a value or index.
        pIdentifier 
        firstCompoundInputToken = pIdentifier
        pInteger
        pStringLiteral
        lastCompoundInputToken = pStringLiteral

        % Non-compound tokens - 
        %   These tokens simply represent themselves.
        pNewLine
        pEndFile
        pPlus                   '+'
        pMinus                  '-'
        pStar                   '*'
        %ColonEquals input token removed
        pDot                    '.'
        pComma                  ','
        pSemicolon              ';'
        pColon                  ':'
        pSlash                  '/'     %Slash input token added
        pPercent                '%'     %Percent input token added
        pOrBar                  '|'
        pNot                    '!'     %Not output input added
        pUnderscore             '_'     %Underscore input token added
        pQuestionMark           '?'     %Question mark input token added
        pDoubleAmpersand        '&&'    %DoubleAmpersand input token added
        pDoubleOrBar            '||'    %Double or bar input token added
        pEquals                 '='
        pDoubleEquals           '=='    %DoubleEquals input token added
        pPlusEquals             '+='    %PlusEquals input token added
        pMinusEquals            '-='    %MinusEquals input token added
        pEqualGreater           '=>'
        pNotEqual               '!='
        pLess                   '<'
        pLessEqual              '<='
        pGreaterEqual           '>='
        pGreater                '>'
        pLeftParen              '('
        pRightParen             ')'
        pRightBrace             '}'     %RightBrace input token added
        pLeftBrace              '{'     %LeftBrace input token added
        pLeftBracket            '['
        pRightBracket           ']'
        lastSyntaxToken = pRightBracket;

Output :
        sIdentifier 
        firstSemanticToken = sIdentifier
        firstCompoundSemanticToken = sIdentifier
        sInteger
        sStringLiteral
        lastCompoundSemanticToken = sStringLiteral

        sProgram
        sParmBegin
        sParmEnd
        sConst
        sType
        sVar
        sProcedure
        sBegin
        sEnd
        sNegate
        sModule         %Added QUST Module output
        sPublic         %Added QUST Module output
        sMutable        %Added QUST variable output token
        sInitialValue   %Added QUST variable output token
        sArray
        sFile
        sRange
        sCaseStmt
        sCaseOtherwise   %added QUST case alternative token
        sCaseEnd
        sLabelEnd
        sExpnEnd
        sNullStmt
        sAssignmentStmt
        sSubscript
        sCallStmt
        sFieldWidth
        sIfStmt
        sThen
        sElse
        sWhileStmt
        %Removed PT tokens RepeatStmt and RepeatEnd
        sLoopStmt       %added QUST output token
        sLoopBreakIf    %added QUST output token
        sLoopEnd        %added QUST output token
        sEq
        sNE
        sLT
        sLE
        sGT
        sGE
        sAdd
        sSubtract
        sMultiply
        sDivide
        sModulus
        sInfixOr
        sOr
        sInfixAnd
        sSubstring      %Added QUST string operation
        SLength         %Added QUST string operation
        sAnd
        sNot
        sNewLine
        sEndOfFile
        lastSemanticToken = sEndOfFile;


rules

Program :
    pMod  
    'main' %program/module name
	[
		|'(': 
			.sProgram
			{
				[
					|pIdentifier:
			    		  .sIdentifier
			    			[
							| ',':
							| *:
				    			>
			    			]
					|*:
						> 
				]
			}
			')'
			.sParmEnd
			'{'
			@Block
		|'{':
			.sModule
			@Block
	];

Block :
        % Strictly speaking, standard Pascal requires that declarations
        % appear only in the order consts, types, vars, procedures.
        % We allow arbitrary intermixing of these instead to preserve
        % programmer sanity.
	.sBegin
	{[                   %%TODO: Re-order case block for expected occurance
        | '}':
            >
        | 'const':
            pConst .sConst
            @ConstantDefinitions
        | 'type':
            .sType
           @TypeDefinitions
        | 'let':
            .sVar
            %@VariableDeclarations
        | 'fn':
            .sProcedure
            % routine name
            pIdentifier  .sIdentifier
            @ProcedureHeading
            @Block
        | 'pub':
            'fn'
            .sProcedure
            % routine name
            pIdentifier .sIdentifier
            .sPublic
            @ProcedureHeading
            @Block
        | pIdentifier:
            %@AssignmentOrCallStmt
        | pIf:
            %@IfStmt
        | pMod:         %%This expects that we don't have nested programs
            %@ModuleStmt
        | pLoop:    
            %@LoopStmt        
        | pMatch:
            %@MatchStmt
        | pWhile:
            %@WhileStmt
	]}
	.sEnd;

ConstantDefinitions :
        % Accept one or more named constant definitions
        pIdentifier  .sIdentifier
        '=' @ConstantValue ';'
        {[
            | pIdentifier:
                .sIdentifier
                '=' @ConstantValue ';'
            | *:
                >
        ]};

ConstantValue :
        [
            | pInteger:
                .sInteger
            | pIdentifier:
                .sIdentifier
            | '-':
                @UnsignedIntegerConstant
                .sNegate
            | '+':
                @UnsignedIntegerConstant
            | pStringLiteral:
                .sStringLiteral
        ];

UnsignedIntegerConstant :
        [
            | pIdentifier:
                .sIdentifier
            | pInteger:
                .sInteger
        ];

TypeDefinitions :
        % Type can only accept one definition per call
        pIdentifier  .sIdentifier
        '='  @TypeBody  ';'
	; % end of type definition
	
	%--- following loop choice block is removed
       	%---{[ 
       	%---    | pIdentifier:
       	%---        .sIdentifier
       	%---        '='  @TypeBody  ';'
       	%---    | *:
       	%---        >
       	%---]};

TypeBody :
        [
	%--- Remove '..' choice and add '[',']' for array range
            |'[':   %  'array': 
                .sArray
                @SimpleType
		']'
            | 'file':
                .sFile
                'of'  @SimpleType
            | *:
                @SimpleType
        ];

SimpleType :
        % A simple type is a named type (possibly predefined)
        % or a subrange type specification
        [
            | pIdentifier:
                .sIdentifier
                [
                    | ',': %---changed '..' to ','
                        .sRange         %% this may be unnecessary
                        @OptionallySignedIntegerConstant
                    | *:
                ]
            | *:
	%--- removed no longer valid beg .. end range dec
        	%---@OptionallySignedIntegerConstant
        	%---    '..'  .sRange
        	%---@OptionallySignedIntegerConstant
        ];

OptionallySignedIntegerConstant :
        [
            | '-':
                @UnsignedIntegerConstant
                .sNegate
            | '+':
                @UnsignedIntegerConstant
            | *:
                @UnsignedIntegerConstant
        ];

VariableDeclarations :
        % Accept one or more variable declarations.
        pIdentifier  .sIdentifier
        ':'  @TypeBody  ';'
        {[
            | pIdentifier:
                .sIdentifier
                ':'  @TypeBody  ';'
            | *:
                >
        ]};

ProcedureHeading :
        % Accept zero or more procedure formal parameter declarations.
        [
            | '(':
                {
                    % formal parameter identifier
                    [
                        | 'mut':
                            pIdentifier  .sIdentifier
                            .sVar
                        | *:
                            pIdentifier  .sIdentifier
                    ]
                    ':'
                    % type identifier
                    pIdentifier  .sIdentifier
                    [
                        | ',':
                        | *:
                            >
                    ]
                }
                ')'
            | *:
        ]
        .sParmEnd;

%Statement :
%        [
%            | pIdentifier:
%                @AssignmentOrCallStmt
%            | 'begin':
%                @BeginStmt
%            | 'if':
%                @IfStmt
%            | 'while':
%                @WhileStmt
%            | 'case':
%                @CaseStmt
%            | 'repeat':
%                @RepeatStmt
%            | *:
%                .sNullStmt
%        ];
%
%AssignmentOrCallStmt :
%        [
%            | ':=':
%                .sAssignmentStmt
%                .sIdentifier    % identifier accepted in the Statement rule
%                @Expression
%                .sExpnEnd
%            | '[':
%                .sAssignmentStmt
%                .sIdentifier
%                .sSubscript
%                @Expression
%                .sExpnEnd
%                ']'  ':='
%                @Expression
%                .sExpnEnd
%            | *:
%                @CallStmt
%        ];
%
%CallStmt :
%        .sCallStmt
%        .sIdentifier    % procedure identifier accepted in the Statement rule
%        % accept zero or more actual parameters
%        [
%            | '(':
%                {
%                    @Expression
%                    .sExpnEnd
%                    % allow a field width specification to occur in calls
%                    % to the standard procedures write and writeln
%                    [
%                        | ':':
%                            .sFieldWidth
%                            @Expression
%                            .sExpnEnd
%                        | *:
%                    ]
%                    [
%                        | ',':
%                        | *:
%                            >
%                    ]
%                }
%                ')'
%            | *:        % no actual parameters
%        ]
%        .sParmEnd;
%
%BeginStmt :
%        .sBegin
%        {
%            @Statement
%            [
%                | ';':
%                | 'end':
%                    .sEnd
%                    >
%            ]
%        };
%
%IfStmt :
%        .sIfStmt
%        @Expression
%        .sExpnEnd
%        'then'  .sThen
%        @Statement
%        [
%            | 'else':
%                .sElse
%                @Statement
%            | *:
%        ];
%
%CaseStmt :
%        .sCaseStmt
%        @Expression
%        .sExpnEnd
%        'of'
%        @CaseAlternative
%        {[
%            | ';':
%                % since case alternatives cannot be null, allow
%                % for the common situation of an extra semicolon
%                % at the end of the list of case alternatives.
%                [
%                    | 'end':
%                        >
%                    | *:
%                        @CaseAlternative
%                ]
%            | 'end':
%                >
%        ]}
%        .sCaseEnd;
%
%CaseAlternative :
%        % A case alternative is a statement labelled by
%        % one or more optionally signed integer constants
%
%        {
%            @OptionallySignedIntegerConstant
%            [
%                | ',':
%                | *:
%                    >
%            ]
%        }
%        .sLabelEnd
%        ':'  @Statement;
%
%WhileStmt :
%        .sWhileStmt
%        @Expression
%        .sExpnEnd
%        'do'
%        @Statement;
%
%RepeatStmt :
%        .sRepeatStmt
%        {
%            @Statement
%            [
%                | ';':
%                | 'until':
%                    .sRepeatEnd
%                    >
%            ]
%        }
%        @Expression
%        .sExpnEnd;
%
%Expression :
%        @SimpleExpression
%        [
%            | '=':
%                @SimpleExpression  .sEq
%            | '<>':
%                @SimpleExpression  .sNE
%            | '<':
%                @SimpleExpression  .sLT
%            | '<=':
%                @SimpleExpression  .sLE
%            | '>':
%                @SimpleExpression  .sGT
%            | '>=':
%                @SimpleExpression  .sGE
%            | *:
%        ];
%
%SimpleExpression :
%        [
%            | '+':
%                @Term
%            | '-':
%                @Term  .sNegate
%            | *:
%                @Term
%        ]
%        {[
%            | '+':
%                @Term  .sAdd
%            | '-':
%                @Term  .sSubtract
%            | 'or':
%                .sInfixOr  @Term  .sOr
%            | *:
%                >
%        ]};
%
%Term :
%        @Factor
%        {[
%            | '*':
%                @Factor  .sMultiply
%            | 'div':
%                @Factor  .sDivide
%            | 'mod':
%                @Factor  .sModulus
%            | 'and':
%                .sInfixAnd  @Factor  .sAnd
%            | *:
%                >
%        ]};
%
%Factor :
%        [
%            | pIdentifier:
%                .sIdentifier
%                @IdentifierExtension
%            | pInteger:
%                .sInteger
%            | '(':
%                @Expression  ')'
%            | 'not':
%                @Factor
%                .sNot
%            | pStringLiteral:
%                .sStringLiteral
%            | 'file':
%                .sFile '(' @Expression ')'
%                .sExpnEnd
%        ];
%
%IdentifierExtension :
%        % Handle subscripts and function actual parameter lists
%        [
%            | '[':
%                .sSubscript
%                @Expression  ']'
%                .sExpnEnd
%            | '(':
%                .sParmBegin
%                @Expression  ')'
%                .sExpnEnd
%                .sParmEnd
%            | *:
%        ];
%
end

