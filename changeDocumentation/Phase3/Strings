#Changes in semantic.ssl Operands, AssignProcedure, ConstantValue rules:
Why: Removal of tpPackedArrays as it is no longer the proper presentation for Strings
How: remove tpPackedArrays boundary checking and pushes tpString
and and omit proper String Length after tLiteralString

#Changes in  semantic.pt oAllocateVariable semantic mechanism:
Why: String size in Qust is 1024 which is way larger than wordSize
How: adds extra choice in semantic mechanism to allocate stringSize.

#Changes in semantic.ssl AssignProcedure, WriteText, ReadText rules:
Why: token are no longer trWriteChar/ReadChar as Strings in Qust handles that
How: now accepts tpString instead of tpPackedArray and emits length of string
using oValuePush(stringSize) and oValueOmit

#Changes in semantic.ssl Operand rule:
To implement new string assignments the operand rule was modified to allow for a case where
an sStringLiteral is handeled. When sStringLiteral is detected the symbol stack is pushed with
syExpression because the string literal is an expression and the type stack is pushed with spString
because obviously that is the type. After this the string length is pushed to the value stack so it
can be emitted then the tLiteralString token is emitted followed by the length value from the value
stack and then the string is emitted and finally the string length is poped off the value stack.

#Changes in semantic.ssl to ConstantValue rule:
To implement const string declarations the case for sStringLiteral was modified for the new Qust
strings. Inside this case first the symbol kind is set to syVariable and the type is set to tpString
and then the standard type stdString is linked. This linked type is then pushed to the type stack 
and EnterVariableAttributes is then called to allocate storage for the string. Following this the
typical assignment t-tokens tAssignBegin and tLiteralAddress are emitted along with the value of the
address itself. Next, approximatly the same sequence as described in the paragraph above was performed 
to output the necisary tokens for a string literal including the .StringLiteral token, string length,
and the string itself. Finally the symbol stack's top element is changed to syConstant so that it can
not be assigned to in the future and the type stack elements that were used in this section are poped.

#Changes in semantic.ssl to UnaryOperator rule:
A new case was added in the main section of this rule to accept the sLength token denoting the string
length operator. Inside this case alternative we first perform an oTypeStackChooseKind choice to be
sure that the type stack has a string b/c otherwise the length operator is being performed on an invalid 
type and should throw an error. Once The type is confirmed to be a string the tLength token is emitted
and the string type is poped from the type stack and an tpInteger is pushed to the type stack because 
the result of this operator is an integer.

#Changes in semantic.ssl to BinaryOperator rule: 
In the main section of the BinaryOperator rule a new case was added to handle the new sSubstring operator.
This case starts by emitting the desired tSubstring token followed by a push to type stack to set the 
operator required result type of tpInteger. CompareOperandAndResultTypes is then called to be sure both
operands are also tpIntegers and then the two operands are poped inside the CompareOperandAndResultTypes
rule. Following this we pop the integer type from the type stack because it's job is now done and then we
check to make sure that the next type is tpString because that is what we are performing the substring 
operations on. We then pop the element from the symbol stack and set it's top element to be and syExpression 
because that is what we've got here.

In the body of the BinaryOperator rule we've also made a number of changes to existing cases The first is
sAdd case which handles addition as well as straing concatenation. The first thing we do in the case block
is check if the type stack contains a string type and if not we perform the old addition code and if not we
enter the new string concatenation. In this part we emit a tConcatenate token as expected and then push a
tpString to the type stack as this is the reulting type from this operarion. We then call 
CompareOperandAndResultTypes which in this case makes sure that the operands are both strings and then leaves
the type stack with only one tpString and then sets up the symbol stack to be with an syExpression.

The next change made was to the sEq and sNE cases where we sinply evaluate if we're handeling a string and if
so we emit tStringEqual for the sEq case and tStringEqual followed by tNot for the sNE case to flip the boolean
value. We then finish handeling string equality by calling CompareEqualityOperandTypes to be sure that both
operands are of the same type. If a string type wasn't on the stack we simply perform the old functionality
the sEq and sNE cases.

The next change was made to the sGT, sGE, sLT, and sLE rules where again we have a special case for when the
type stack containts a string. In this special case we simply emit an eInvalidExpn because these operators
operating on a string is invalid. If a string is not detected appropriate t-token is emmitted and then
regardless of string or not we perform CompareRelationalOperandTypes. We do this even in the invalid case so
that the stack can be set correctly and won't cause a cascade of errors in rest of the compiled code.

Finally, the sMultiply rule was changed wherein we start by calling oTypeStackSwap because we want to know
if the second element in type stack is a string. If it's not we carry on with typical multiplication but
if it is then we start into a section to handle the repeat operator. In this section we emit the
appropriate token and flip the type stack because and check that the top element is now and integer b/c
otherwise we would have an invalid repeat operation. If all is well we pop the integer type of the type
and symbol stack and set the symbol stack kind to syExpression. The type stack is simply left because 
it now contains the resulting type of the repeat string operation. 
>>>>>>> 4e54659973e0a57e152641cc44c73ca3759fc7b7
